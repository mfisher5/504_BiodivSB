---
title: "Variable Selection Question 2"
author: "Mary Fisher"
date: "February 28; Updated March 13"
output: 
  html_document:
    toc: yes
    toc_float: yes
---

#### Research Question: Which oceanographic and herbivory conditions are important for predicting giant kelp size and abundance?

**Response variables:** Giant kelp mean abundance, max abundance; Giant kelp mean size, maximum size. 

**Predictor variables: **

1. Urchin abundance: Sea urchins are herbivores, and in large numbers (also called "herds") can decimate kelp forests. We have three measures of urchin abundance - red urchin abundance, purple urchin abundance, and urchin abundance across all species.

2. Water chemistry: Like any algae / plant, kelp requires nutrients to grow. We have measurements for the following nutrients: nitrogen, ammonia, urea, and phosphorus. We also have chlorophyl concentrations, which is a general index of primary productivity.

3. Water temperature: All species have a thermal range, or a range of temperatures, at which they grow best; the degree of variability in temperature can also have an impact on growth. With kelp forest loss from recent marine heatwaves and long-term warming, there has been much interest in whether kelp are impacted by an absolute temperature threshold, or by the degree of variability in temperature. We have mean summer and mean winter temperatures, and variation in summer and mean winter temperatures. 

4. Giant kelp mean / max abundance, mean / max size at t-1: This data set is a time series, so the giant kelp response variable at a given site for year `t` should be dependent on giant kelp condition in year `t-1`.


**Modeling approach:** OLS incorporating previous size / abundance.



```{r setup, include=FALSE}
rm(list=ls())

knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(janitor)
library(here)
library(vegan)
library(lubridate)
library(corrplot)
library(MASS)
library(performance)

```
<br>

## Prepare Data

Read in data
```{r echo=TRUE}
mydat <- read.csv(here::here("data","kelp_prediction_data_complete.csv")) %>%
  clean_names()
head(mydat)
```
<br>

Add in the giant kelp response variables for `t-1`.
```{r}
# need kelp info from 2001
kelp_dat <- read.csv(here::here("data","Annual_Kelp_MeanSize_MeanAbund_2001-2018.csv")) %>%
  clean_names() %>%
  filter(site %in% mydat$site & year == 2001) %>%
  dplyr::select(-month) %>%
  rename("prev_mean_density" = mapy_mean_density,
         "prev_mean_count"=mapy_mean_count,
         "prev_mean_fronds"=mapy_mean_fronds,
         "prev_max_fronds"=mapy_max_fronds,
         "prev_mean_hld"=mapy_mean_hld,"prev_max_hld"=mapy_max_hld) %>%
  mutate(year = year + 1)
kelp_prev <- read.csv(here::here("data","kelp_prediction_data.csv")) %>%
  clean_names() %>%
  dplyr::select(year,month,site,mapy_mean_density,mapy_mean_count,mapy_mean_fronds,mapy_max_fronds,mapy_mean_hld,mapy_max_hld) %>%
  rename("prev_mean_density" = mapy_mean_density,
         "prev_mean_count"=mapy_mean_count,
         "prev_mean_fronds"=mapy_mean_fronds,
         "prev_max_fronds"=mapy_max_fronds,
         "prev_mean_hld"=mapy_mean_hld,"prev_max_hld"=mapy_max_hld) %>%
  mutate(year = year + 1) %>%
  dplyr::select(-month) %>%
  rbind(kelp_dat)
mydat <- left_join(mydat,kelp_prev,by=c("year","site"))

message("\nThere are ", sum(is.na(mydat$prev_mean_density)), " missing measurements for the previous year's kelp abundance.\n")

colnames(mydat)
```
<br>

## Predictor Variables 

### Herbivory

We have three variables that quantify urchin abundance - we'll just work with total abundance (`urchin_abundance`). 

This variable is zero-inflated, a common problem with ecological count data. So I'm going to split it into two predictor variables - a categorical presence / absence variable, and then an abundance variable.

First, get rid of the species-specific counts
```{r echo=TRUE}
lmdat <- dplyr::select(mydat, -purpuratus_abundance,-franciscanus_abundance)
```
<br>

Then grab the total abundance data and split it into the two new variables. Does the square root transformation of the urchin abundance variable look normal now?
```{r echo=TRUE}
lmdat <- lmdat %>%
  mutate(urchin_presence = ifelse(urchin_abundance > 0, 0, 1),
         urchin_abundance = ifelse(urchin_abundance==0,NA,sqrt(urchin_abundance)))
```
```{r}
ggplot(lmdat,aes(x=urchin_abundance)) +
  geom_histogram() + theme_bw()

shapiro.test(lmdat$urchin_abundance)
```
<br>

### Water Chemistry

The maximum values of water chemistry estimates were very difficult to force into a normal distribution. So I'm only going to work with the mean values.

```{r echo=TRUE}
lmdat <- lmdat %>%
  dplyr::select(-max_ammonia,-max_no2_no3,-max_po4,-max_poc,-max_pon,-max_tchl)
colnames(lmdat)
```
<br>


### Multicolinearity

Let's ignore the previous kelp size / abundance for now.

```{r}
corrplot(cor(lmdat[,c(10:20)],use="complete.obs"), type="upper")
```
<br>

Summer and winter temperatures are correlated; since kelp is a cold-water species, we'll stick with summer temperature only. But then summer temperatures are also highly correlated with a variety of water chemistry variables, so let's just take out temperature entirely. 

```{r echo=TRUE}
lmdat <- lmdat %>%
  dplyr::select(-winter_mean_temp,-winter_var_temp)
```
<br>

```{r}
corrplot(cor(lmdat[,c(10:18)],use="complete.obs"), type="upper")
```

Particulate organic carbon (`poc`) is highly correlated with particulate organic nitrogen and mean total chlorophyll. I'll remove particulate organic carbon.

```{r echo=TRUE}
lmdat <- lmdat %>%
  dplyr::select(-mean_poc)
```

```{r}
corrplot(cor(lmdat[,c(10:17)],use="complete.obs"), type="upper")
```

I think that for the remaining correlations, I'll see what happens in stepwise model selection. These are the final variables:
```{r}
colnames(lmdat)
```
<br>

### Transform variables
According to the script [04_explore_predictors](https://github.com/mfisher5/504_BiodivSB/tree/master/scripts), many of the predictor variables are not normally distributed. 

```{r echo=TRUE}
lmdat.t <- lmdat %>%
  mutate(summer_var_temp = log(summer_var_temp),
         mean_pon= log(mean_pon),
         mean_tchl= log(mean_tchl))
```
<br>
```{r}
par(mfrow=c(2,2))
hist(lmdat.t$urchin_abundance, main="")
hist(lmdat.t$mean_ammonia, main="")
hist(lmdat.t$mean_no2_no3, main="")
hist(lmdat.t$mean_po4, main="")
hist(lmdat.t$mean_pon, main="")
hist(lmdat.t$mean_tchl, main="")
hist(lmdat.t$summer_mean_temp, main="")
hist(lmdat.t$summer_var_temp, main="")
```
<br>
<br>


## Response Variables

Mean holdfast diameter is normal (yay!).

Mean density and mean number of fronds need to be log-transformed. I think that means that I can just run a generalized linear model using the `family=poisson(link='log')` argument. 

But I do need to run the variable transformation for the previous mean density / fronds
```{r echo=TRUE}
lmdat.t <- lmdat.t %>%
  mutate(prev_mean_density = log(prev_mean_density),
         prev_mean_count = log(prev_mean_count),
         prev_mean_fronds = log(prev_mean_fronds))
```
```{r}
par(mfrow=c(1,3))
hist(lmdat.t$prev_mean_density,main="")
hist(lmdat.t$prev_mean_count,main="")
hist(lmdat.t$prev_mean_fronds,main="")
```
<br>

Maximum number of fronds and holdfast diameter need a square root transformation. For the response variable, this means that I can just run a generalized linear model using `family=Gamma(link='sqrt')`. 

But I do need to transform the previous fronds and holdfast diameter.
```{r echo=TRUE}
lmdat.t <- lmdat.t %>%
  mutate(prev_max_fronds = sqrt(prev_max_fronds),
         prev_max_hld = sqrt(prev_max_hld))
```
```{r}
par(mfrow=c(1,2))
hist(lmdat.t$prev_max_fronds,main="")
hist(lmdat.t$prev_max_hld,main="")
```
<br>








<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
---










